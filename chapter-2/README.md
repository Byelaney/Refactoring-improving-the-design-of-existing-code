# Chapter 2 重构的法则


上一章节的例子应该大体上让你明白了什么是重构。现在是时候让我们来回顾一下关于重构的那些法则了。

## 定义什么是重构

就像其他软件开发的术语一样，“重构”这个词也经常会被不准确地使用。“重构”可以被用作名词和动词，定义如下：

> **Refactoring (noun)**: 是对软件内部结构的一种改变，这种改变可以使代码更容易被理解和更改，并且不能改变软件对外的行为。

> **Refactoring (verb)**:对软件进行一系列的重构（名词），并且不改变软件对外的行为。

在过去的几十年间，许多业界人员都会错误地使用“重构”这个词，他们认为任何对代码的清理都能被称为是“重构”。事实上重构是由一系列小的重构组成的，重要的是每次你的重构都足够的小，因为足够小，所以你的软件还是能够正常运行并且很容易进行，这些小的步骤最后会成为一个大的重构，

> 如果有人和你说他把代码重构坏了，那么你应该很确定他不是在重构。

我使用 “restructuring” 这个词来指代对 code base 的任何 reorganizing 或者 cleaning up ，并且把重构看作是 “restructuring” 的一种。第一次见我重构的人可能会认为这样效率很低，我进行很多很小的步骤来重构，而不是一次性修改很大一部分。但最终正是这些小步骤让我能够更快地进行下去，因为我根本不用花费很多时间去 debugging。

在我的定义里，我提到了“软件对外的行为”，这里的意思简单来说就是在重构完之后程序应该和重构完之前有一样的功能。并不是说程序内部运行和重构之前一模一样，比如调用栈，性能等等。这里的功能应该是指用户所真正关心的功能。

重构和性能优化非常相似，因为它们都不应该改变程序的功能。区别在于彼此的目的：重构总是为了“使代码更容易被理解和更改”，这可能使程序变慢但也可能变快。对性能优化而言，我只考虑怎么使程序变快，有时不可避免的会需要难以理解的代码。

## 两顶帽子

Kent Beck 对此有一个 two hats 的比喻。当你使用重构来开发软件的时候，你把时间分配在两个不同的方面：增加新功能和重构。当我增加新功能的时候，我不应该改变原有的代码；我只是在增加新的功能。我通过增加新的测试来衡量我的工作进程。当我重构的时候，我不应该增加新的功能；我只是在 restructure 我的代码。我不用增加任何的测试（除非我发现之前有遗漏）。

当我自己开发软件的时候，我发现我经常换着戴这两顶“帽子”。我刚开始是想增加新的功能，但有时候会发现如果我重新组织代码，会更容易达到我增加新功能的目的。所以我换帽子到“重构”了。一旦代码有了更好的组织结构，我再换帽子到“增加功能”，并且增加功能。一旦新功能增加好了，我可能又意识到我写的代码实在太难理解了，所以我又换帽子并且重构并且重构。整个过程可能只有十分钟，但是我总是有意识的知道我在干什么。

## 为什么要重构？

我不会说“重构可以解决软件的所有问题”，它不是 “silver bullet”（银弹）。但它是一种珍贵的控制代码的工具，并且可以或者说应该被广泛使用。

## 重构提高软件的设计

如果没有重构，软件的结构会有衰变的倾向。随着开发者为了各种短期目的改变代码（常常没有很好的理解架构），代码会渐渐地失去原有的结构，并且这会有一种累积的效果，代码越是难读懂，开发者越是会乱改，于是代码的结构衰变的越快。定期的重构有助于维护代码的结构。

设计不良的代码通常会需要更多的代码来做同一件事，经常是因为在很多地方散落了重复的代码。因此改善设计的一个重要方面就是要避免重复代码。并不是因为减少了代码数量系统会变得那么的快而重要，减少重复代码会对你以后改变代码起巨大的作用。代码越多，越是难正确地去修改，因为你要理解更多的代码。我在一个地方修改了代码，但是系统并没有按我理解的去运行，这是因为在另一个地方也有同样的代码但我却没有修改。通过避免重复代码，我能够保证某部分代码 `says everything once and only once`，这正是良好设计的核心。
